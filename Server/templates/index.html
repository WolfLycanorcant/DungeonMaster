<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Master RPG</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #34495e;
            --accent-color: #3498db;
            --text-color: #ecf0f1;
            --panel-bg: #2c3e50;
            --input-bg: #34495e;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 15px;
            background-color: #1a1a1a;
            color: var(--text-color);
            line-height: 1.6;
        }

        h1 {
            text-align: center;
            color: var(--accent-color);
            margin: 0 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--accent-color);
        }

        #character-creation,
        #save-load-panel {
            margin: 0 auto 20px;
            padding: 20px;
            max-width: 600px;
            border: 1px solid var(--accent-color);
            border-radius: 8px;
            background-color: var(--panel-bg);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        
        #save-load-panel {
            display: none; /* Hidden by default, shown after game starts */
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--accent-color);
        }

        input[type="text"],
        select,
        button,
        .btn {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid var(--accent-color);
            border-radius: 6px;
            font-size: 16px;
            background-color: var(--input-bg);
            color: var(--text-color);
            transition: all 0.3s ease;
            margin-bottom: 10px;
            cursor: pointer;
        }

        button, .btn {
            background-color: var(--accent-color);
            color: white;
            cursor: pointer;
            font-weight: 600;
            text-align: center;
            text-decoration: none;
            display: inline-block;
        }

        button:hover, .btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        #game-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        .game-layout {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #combat-area {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
        }

        .character-status {
            border: 1px solid #ddd;
            padding: 15px;
            text-align: center;
        }

        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
        }

        #console-container {
            flex: 1;
            border: 1px solid #ccc;
            padding: 20px;
            height: 600px;
            overflow-y: auto;
            background-color: #f5f5f5;
        }

        #console-output {
            height: 300px;
            overflow-y: auto;
            background: #1a1a1a;
            color: #00ff00;
            font-family: 'Courier New', Courier, monospace;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 6px;
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .console-entry {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
        }
        
        .console-command {
            color: #3498db;
            font-weight: bold;
            margin: 8px 0;
            padding: 8px 12px;
            background-color: rgba(52, 152, 219, 0.1);
            border-left: 3px solid #3498db;
            border-radius: 0 4px 4px 0;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .console-response {
            color: #2ecc71;
            margin: 8px 0;
            padding: 8px 12px;
            background-color: rgba(46, 204, 113, 0.1);
            border-left: 3px solid #2ecc71;
            border-radius: 0 4px 4px 0;
            font-family: 'Courier New', monospace;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .console-error {
            color: #e74c3c;
            margin: 8px 0;
            padding: 8px 12px;
            background-color: rgba(231, 76, 60, 0.1);
            border-left: 3px solid #e74c3c;
            border-radius: 0 4px 4px 0;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .console-info {
            color: #3498db;
            margin: 8px 0;
            padding: 8px 12px;
            background-color: rgba(52, 152, 219, 0.1);
            border-left: 3px solid #3498db;
            border-radius: 0 4px 4px 0;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .console-system {
            color: #9b59b6;
            font-style: italic;
            margin: 8px 0;
            padding: 8px 12px;
            background-color: rgba(155, 89, 182, 0.1);
            border-left: 3px solid #9b59b6;
            border-radius: 0 4px 4px 0;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .console-success {
            color: #2ecc71;
            font-weight: bold;
            margin: 8px 0;
            padding: 8px 12px;
            background-color: rgba(46, 204, 113, 0.1);
            border-left: 3px solid #2ecc71;
            border-radius: 0 4px 4px 0;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            word-break: break-word;
        }

        #console-input {
            width: 100%;
            padding: 12px 15px;
            margin: 10px 0;
            border: 1px solid var(--accent-color);
            border-radius: 6px;
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 16px;
        }

        /* Mobile-specific styles */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            #console-output {
                height: 200px;
                font-size: 14px;
                padding: 10px;
            }

            .display-panel {
                padding: 12px;
                max-height: 300px;
            }

            button, .btn, input[type="text"], select, #console-input {
                padding: 10px 12px;
                font-size: 15px;
            }

            .character-creation-form {
                padding: 10px;
            }

            .combat-actions {
                flex-direction: column;
                gap: 8px;
            }
        }

        /* Small mobile devices */
        @media (max-width: 480px) {
            #console-output {
                height: 180px;
                font-size: 13px;
            }

            h1 {
                font-size: 24px;
                margin-bottom: 15px;
            }

            .character-sheet {
                padding: 10px;
            }

            .inventory-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }
        }

        /* Console message styling */
        .console-message {
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Button group for actions */
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 10px 0;
        }

        .button-group button {
            flex: 1 1 45%;
            min-width: 120px;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #2c3e50;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: #4a6b8a;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #5a7b9a;
        }

        /* Combat area improvements */
        .combat-area {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 15px 0;
        }

        .combatant {
            background: rgba(52, 73, 94, 0.7);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }

        .health-bar {
            height: 20px;
            background: #e74c3c;
            border-radius: 10px;
            margin: 5px 0;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: #2ecc71;
            width: 100%;
            transition: width 0.3s ease;
        }

        /* Input group for better mobile */
        .input-group {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        .input-group input[type="text"] {
            flex: 1;
            margin: 0;
        }

        .input-group button {
            width: auto;
            min-width: 80px;
            margin: 0;
        }

        .equipment-grid {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
        }

        .grid-header {
            text-align: center;
            margin-bottom: 15px;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            grid-auto-rows: 80px;
        }

        .grid-item {
            background-color: white;
            padding: 15px;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: 100%;
            min-height: 80px;
        }

        .icon-container {
            width: 48px;
            height: 48px;
            margin: 0 auto 10px;
            border-radius: 8px;
            overflow: hidden;
            background-color: #f0f0f0;
            position: relative;
        }

        .empty-slot-placeholder {
            width: 100%;
            height: 100%;
            background-color: #ddd;
            border-radius: 8px;
        }

        .item-name {
            font-size: 14px;
            color: #666;
            margin-top: 4px;
        }

        .empty-slot {
            opacity: 0.5;
        }

        .game-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }

        .game-buttons button {
            flex: 1 1 150px;
            min-width: 120px;
            padding: 10px;
            background-color: #4a6fa5;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .game-buttons button:hover {
            background-color: #3a5a80;
        }
        
        /* Status Panel Styles */
        .display-panels {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        
        .display-panel {
            flex: 1;
            background: var(--panel-bg);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            overflow: auto;
            color: #ecf0f1;
            display: none;
            max-height: 500px;
            position: relative;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #34495e;
        }
        
        .panel-header h3 {
            margin: 0;
            color: #3498db;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: #95a5a6;
            font-size: 24px;
            cursor: pointer;
            padding: 0 8px;
            line-height: 1;
        }
        
        .close-btn:hover {
            color: #e74c3c;
        }
        
        /* Status Card */
        .status-card {
            background: #34495e;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .status-header h4 {
            margin: 0;
            color: #2ecc71;
        }
        
        .level {
            background: #3498db;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.9em;
        }
        
        /* Progress Bars */
        .progress-bar {
            background: #2c3e50;
            height: 20px;
            border-radius: 10px;
            margin: 5px 0;
            overflow: hidden;
            position: relative;
        }
        
        .progress {
            height: 100%;
            background: #2ecc71;
            min-width: 20px;
            border-radius: 10px;
            transition: width 0.3s ease;
        }
        
        .progress.health { background: #e74c3c; }
        .progress.mana { background: #3498db; }
        .progress.exp { background: #f1c40f; }
        
        .status-section {
            margin-top: 15px;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }
        
        .equipment-display {
            margin-top: 10px;
        }
        
        .equipment-item {
            display: flex;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .equipment-slot {
            font-weight: bold;
            min-width: 100px;
            color: #3498db;
        }
        
        .equipment-name {
            flex-grow: 1;
        }
        
        .equipment-durability {
            color: #95a5a6;
            font-size: 0.9em;
        }
        
        .equipment-empty {
            color: #7f8c8d;
            font-style: italic;
            padding: 5px 0;
        }
        
        .value {
            position: absolute;
            right: 8px;
            top: 0;
            line-height: 20px;
            font-size: 0.8em;
            color: white;
            text-shadow: 0 0 2px rgba(0,0,0,0.5);
        }
        
        /* Stats Grid */
        .status-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .stat {
            background: #2c3e50;
            padding: 8px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
        }
        
        .stat.gold {
            background: #f1c40f;
            color: #2c3e50;
            font-weight: bold;
            grid-column: 1 / -1;
            justify-content: center;
        }
        
        .label {
            color: #95a5a6;
            margin-right: 10px;
        }
        
        .stat .value {
            position: static;
            color: inherit;
            text-shadow: none;
        }
        
        /* Loading State */
        .loading {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
            font-style: italic;
        }
        
        /* Error State */
        .error-message {
            color: #e74c3c;
            padding: 10px;
            background: rgba(231, 76, 60, 0.1);
            border-radius: 4px;
            margin-top: 10px;
        }

        .game-buttons button.active {
            background-color: #8b0000;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(139, 0, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(139, 0, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(139, 0, 0, 0); }
        }
    </style>
</head>
<body>
    <h1>Dungeon Master RPG</h1>
    
    <div id="game-container">
        <div id="character-creation">
            <h2>Create Your Character</h2>
            <div class="form-group">
                <label for="character-name">Name:</label>
                <input type="text" id="character-name" required>
            </div>
            <div class="form-group">
                <label for="character-class">Class:</label>
                <select id="character-class">
                    <option value="warrior">Warrior</option>
                    <option value="wizard">Wizard</option>
                    <option value="thief">Thief</option>
                    <option value="healer">Healer</option>
                </select>
            </div>
            <button onclick="createCharacter()">Create Character</button>
        </div>

        <!-- Save/Load Panel -->
        <div id="save-load-panel">
            <h2>Game Management</h2>
            <div class="form-group">
                <label for="save-name">Save Name:</label>
                <input type="text" id="save-name" placeholder="Enter save name">
            </div>
            <div class="form-group" style="display: flex; gap: 10px;">
                <button onclick="saveGame()" style="background-color: #27ae60;">Save Game</button>
                <button onclick="loadGame()" style="background-color: #2980b9;">Load Game</button>
            </div>
            <div id="save-status" style="margin-top: 10px; color: #2ecc71; display: none;"></div>
        </div>

        <div id="game-content">
            <div id="game-output"></div>
            
            <div id="player-status">
                <p>Name: <span id="player-name"></span></p>
                <p>Class: <span id="player-class"></span></p>
                <p>Health: <span id="player-health"></span></p>
            </div>

            <!-- Inventory Display Section -->
            <div id="inventory-display" style="margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9; display: none;">
                <h3>Inventory</h3>
                <div id="inventory-items"></div>
            </div>

            <!-- Status and Inventory Panels -->
            <div class="display-panels">
                <!-- Status Panel -->
                <div id="status-panel" class="display-panel">
                    <div class="panel-header">
                        <h3>Character Status</h3>
                        <button class="close-btn" onclick="togglePanel('status')">×</button>
                    </div>
                    <div id="status-content">
                        <div class="loading">Loading character status...</div>
                        <div class="status-section">
                            <h4>Equipment</h4>
                            <div id="equipment-display" class="equipment-display">
                                <div class="equipment-empty">No equipment equipped</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Inventory Panel -->
                <div id="inventory-panel" class="display-panel">
                    <div class="panel-header">
                        <h3>Inventory</h3>
                        <button class="close-btn" onclick="togglePanel('inventory')">×</button>
                    </div>
                    <div id="inventory-content">
                        <div class="loading">Loading inventory...</div>
                    </div>
                </div>
            </div>
            
            <div class="game-buttons">
                <button onclick="lookAround()">Look Around</button>
                <button id="npcButton" class="action-button" onclick="toggleNPCDialogMode()">
                    <i class="fas fa-comment-dots"></i> <span id="npcButtonText">Talk to NPC</span>
                </button>
                <button class="panel-toggle" data-panel="inventory">View Inventory</button>
                <button class="panel-toggle" data-panel="status">Character Status</button>
                <button onclick="sendConsoleCommand('save')">Save Game</button>
                <button onclick="sendConsoleCommand('load')">Load Game</button>
                <button onclick="sendConsoleCommand('help')">Help</button>
            </div>
        </div>
    </div>
    
    <div id="console-container">
        <div id="console-output"></div>
        <div id="console-input-container">
            <input type="text" id="console-input" placeholder="Enter your command..." onkeypress="handleKeyPress(event)" />
            <button onclick="sendConsoleCommand()">Send</button>
        </div>
    </div>

    <script>
        // Console message types
        const CONSOLE_TYPES = {
            COMMAND: 'command',
            RESPONSE: 'response',
            ERROR: 'error',
            INFO: 'info',
            SYSTEM: 'system',
            SUCCESS: 'success'
        };

        // Game state variables
        let currentLocation = 'Starting Town';
        let player = null;
        let enemy = null;
        let combatMode = false;
        let consoleOutput = '';
        
        // Add message to console with type
        function addConsoleMessage(type, message) {
            // Try to find an existing message div of the same type
            let messageDiv = consoleOutputElement.querySelector(`.console-${type}`);
            
            // If no existing message div of this type, create a new one
            if (!messageDiv) {
                messageDiv = document.createElement('div');
                messageDiv.className = `console-${type}`;
                consoleOutputElement.appendChild(messageDiv);
            }
            
            // Preserve newlines in the message
            const formattedMessage = message.replace(/\n/g, '<br>');
            
            // If there's existing content, add a line break before appending
            if (messageDiv.innerHTML) {
                messageDiv.innerHTML += '<br><br>' + formattedMessage;
            } else {
                messageDiv.innerHTML = formattedMessage;
            }
            
            // Scroll to the bottom of the console
            consoleOutputElement.scrollTop = consoleOutputElement.scrollHeight;
        }

        // DOM Elements
        const consoleOutputElement = document.getElementById('console-output');
        const characterCreation = document.getElementById('character-creation');
        const gameContent = document.getElementById('game-content');
        const playerNameElement = document.getElementById('player-name');
        const playerClassElement = document.getElementById('player-class');
        const playerLevelElement = document.getElementById('player-level');
        const playerHealthElement = document.getElementById('player-health');

        // Handle key press in console input
        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendConsoleCommand();
            }
        }
        
        // Send command from console input
        async function sendConsoleCommand() {
            const inputElement = document.getElementById('console-input');
            const command = inputElement.value.trim();
            
            if (!command) return;
            
            // Add command to console
            addConsoleMessage(CONSOLE_TYPES.COMMAND, `> ${command}`);
            
            // Clear input
            inputElement.value = '';
            
            // Handle special commands
            const parts = command.split(' ');
            const cmd = parts[0].toLowerCase();
            const args = parts.slice(1);
            
            try {
                switch (cmd) {
                    case 'save':
                        const saveName = args[0] || 'autosave';
                        document.getElementById('save-name').value = saveName;
                        await saveGame();
                        break;
                        
                    case 'load':
                        const loadName = args[0] || 'autosave';
                        document.getElementById('save-name').value = loadName;
                        await loadGame();
                        break;
                        
                    default:
                        // Send other commands to the server
                        const response = await fetch('/api/command', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                command: command
                            })
                        });
                        
                        const data = await response.json();
                        
                        if (!response.ok) {
                            throw new Error(data.error || 'Command failed');
                        }
                        
                        addConsoleMessage(CONSOLE_TYPES.RESPONSE, data.message || 'Command executed');
                }
            } catch (error) {
                addConsoleMessage(CONSOLE_TYPES.ERROR, error.message);
                console.error('Error executing command:', error);
            }
        }
        
        // Toggle character creation vs game content
        function toggleCharacterCreation() {
            if (!player) {
                characterCreation.style.display = 'block';
                gameContent.style.display = 'none';
            } else {
                characterCreation.style.display = 'none';
                gameContent.style.display = 'block';
            }
        }

        // Create new character
        async function createCharacter() {
            const name = document.getElementById('character-name').value.trim();
            const characterClass = document.getElementById('character-class').value;
            
            if (!name) {
                alert('Please enter a character name');
                return;
            }

            try {
                const response = await fetch('/api/create_character', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        name: name,
                        class: characterClass
                    })
                });


                const data = await response.json();
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to create character');
                }

                player = data.character;
                toggleCharacterCreation();
                // Show the save/load panel after character creation
                document.getElementById('save-load-panel').style.display = 'block';
                updatePlayerStatus();
                updateEquipmentDisplay();
                addConsoleMessage(CONSOLE_TYPES.SUCCESS, 'Character created successfully!');
            } catch (error) {
                addConsoleMessage(CONSOLE_TYPES.ERROR, `Error creating character: ${error.message}`);
            }
        }
        
        // Save the current game state
        async function saveGame() {
            const saveName = document.getElementById('save-name').value.trim() || 'autosave';
            const statusElement = document.getElementById('save-status');
            
            try {
                const response = await fetch('/api/save_game', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        save_name: saveName
                    })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to save game');
                }
                
                // Show success message
                statusElement.textContent = `Game saved as '${saveName}'`;
                statusElement.style.color = '#2ecc71';
                statusElement.style.display = 'block';
                
                // Hide the message after 3 seconds
                setTimeout(() => {
                    statusElement.style.display = 'none';
                }, 3000);
                
                addConsoleMessage(CONSOLE_TYPES.SUCCESS, `Game saved as '${saveName}'`);
                return data;
            } catch (error) {
                statusElement.textContent = `Error saving game: ${error.message}`;
                statusElement.style.color = '#e74c3c';
                statusElement.style.display = 'block';
                addConsoleMessage(CONSOLE_TYPES.ERROR, `Error saving game: ${error.message}`);
                console.error('Error saving game:', error);
            }
        }
        
        // Load a saved game
        async function loadGame() {
            const saveName = document.getElementById('save-name').value.trim() || 'autosave';
            const statusElement = document.getElementById('save-status');
            
            try {
                const response = await fetch('/api/load_game', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        save_name: saveName
                    })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to load game');
                }
                
                // Reload the page to reflect the loaded game state
                location.reload();
                
                return data;
            } catch (error) {
                statusElement.textContent = `Error loading game: ${error.message}`;
                statusElement.style.color = '#e74c3c';
                statusElement.style.display = 'block';
                addConsoleMessage(CONSOLE_TYPES.ERROR, `Error loading game: ${error.message}`);
                console.error('Error loading game:', error);
            }
        }



        async function updatePlayerStatus() {
            try {
                const response = await fetch('/api/get_player_status');
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to get player status');
                }
                
                playerNameElement.textContent = data.name;
                playerClassElement.textContent = data.class;
                playerHealthElement.textContent = data.health;
                
                // Update equipment display when updating status
                if (data.equipment) {
                    updateEquipmentDisplay(data.equipment);
                }
            } catch (error) {
                console.error('Error getting player status:', error);
            }
        }
        
        // Update equipment display with current equipment
        function updateEquipmentDisplay(equipment) {
            try {
                const equipmentContainer = document.getElementById('equipment-display');
                if (!equipmentContainer) return;
                
                // Clear existing equipment
                equipmentContainer.innerHTML = '';
                
                // Add each equipped item to the display
                for (const [slot, item] of Object.entries(equipment || {})) {
                    if (item) {
                        const itemElement = document.createElement('div');
                        itemElement.className = 'equipment-item';
                        itemElement.innerHTML = `
                            <span class="equipment-slot">${slot}:</span>
                            <span class="equipment-name">${item.name || 'None'}</span>
                            ${item.durability ? `<span class="equipment-durability">(${item.durability}%)</span>` : ''}
                        `;
                        equipmentContainer.appendChild(itemElement);
                    }
                }
                
                // If no equipment, show a message
                if (Object.keys(equipment || {}).length === 0) {
                    const noItems = document.createElement('div');
                    noItems.className = 'equipment-empty';
                    noItems.textContent = 'No equipment equipped';
                    equipmentContainer.appendChild(noItems);
                }
                
            } catch (error) {
                console.error('Error updating equipment display:', error);
            }
        }

        // Handle console command input
        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendConsoleCommand();
            }
        }

        async function sendConsoleCommand(command = '') {
            const input = document.getElementById('console-input');
            // If no command is provided, use the input field value
            if (!command) {
                command = input.value.trim();
                if (!command) {
                    return;
                }
                // Clear input if we're using the input field
                input.value = '';
            }
            
            // Add command to console
            addConsoleMessage(CONSOLE_TYPES.COMMAND, command);

            try {
                const response = await fetch('/api/console_command', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        command: command
                    })
                });

                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to process command');
                }

                // Add response to console
                addConsoleMessage(CONSOLE_TYPES.RESPONSE, data.response);
            } catch (error) {
                addConsoleMessage(CONSOLE_TYPES.ERROR, error.message);
            }
        }

        // Add message to console with type
        function addConsoleMessage(type, message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `console-${type}`;
            messageDiv.textContent = message;
            consoleOutputElement.appendChild(messageDiv);
            consoleOutputElement.scrollTop = consoleOutputElement.scrollHeight;
        }

        // Track UI states
        let npcDialogMode = false;
        let currentNPC = '';
        let activePanel = null;
        let inventoryVisible = false;
        
        // Initialize event listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Panel toggle buttons
            document.querySelectorAll('.panel-toggle').forEach(button => {
                button.addEventListener('click', function() {
                    const panelId = this.getAttribute('data-panel');
                    togglePanel(panelId);
                });
            });
        });
        
        // Toggle panel display
        function togglePanel(panelId) {
            const panel = document.getElementById(`${panelId}-panel`);
            
            // If clicking the currently active panel, close it
            if (activePanel === panelId) {
                panel.style.display = 'none';
                activePanel = null;
                return;
            }
            
            // Close any open panel
            if (activePanel) {
                const currentPanel = document.getElementById(`${activePanel}-panel`);
                if (currentPanel) currentPanel.style.display = 'none';
            }
            
            // Open the selected panel
            panel.style.display = 'block';
            activePanel = panelId;
            
            // Load panel content if needed
            if (panelId === 'inventory') {
                fetchInventory();
            } else if (panelId === 'status') {
                fetchCharacterStatus();
            }
        }
        
        // Fetch and display inventory
        async function fetchInventory() {
            const inventoryContent = document.getElementById('inventory-content');
            inventoryContent.innerHTML = '<div class="loading">Loading inventory...</div>';
            
            try {
                const response = await fetch('/api/check_inventory');
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to fetch inventory');
                }
                
                if (data.inventory && data.inventory.length > 0) {
                    const itemsGrid = document.createElement('div');
                    itemsGrid.className = 'items-grid';
                    
                    data.inventory.forEach(item => {
                        const itemElement = document.createElement('div');
                        itemElement.className = 'item-card';
                        
                        let itemHTML = `
                            <div class="item-name">${item.name || 'Unnamed Item'}</div>
                            ${item.description ? `<div class="item-description">${item.description}</div>` : ''}
                            ${item.quantity ? `<div class="item-quantity">Quantity: ${item.quantity}</div>` : ''}
                            ${item.value ? `<div class="item-value">Value: ${item.value} gold</div>` : ''}
                        `;
                        
                        itemElement.innerHTML = itemHTML;
                        itemsGrid.appendChild(itemElement);
                    });
                    
                    inventoryContent.innerHTML = '';
                    inventoryContent.appendChild(itemsGrid);
                } else {
                    inventoryContent.innerHTML = '<div class="empty-message">Your inventory is empty.</div>';
                }
            } catch (error) {
                console.error('Error fetching inventory:', error);
                inventoryContent.innerHTML = `<div class="error-message">Error: ${error.message}</div>`;
            }
        }
        
        // Fetch and display character status
        async function fetchCharacterStatus() {
            const statusContent = document.getElementById('status-content');
            statusContent.innerHTML = '<div class="loading">Loading character status...</div>';
            
            try {
                // First try the direct status endpoint
                let response = await fetch('/api/get_player_status');
                let data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to fetch character status');
                }
                
                // If we have structured data, render it
                if (data.name || data.health !== undefined) {
                    renderStructuredStatus(data);
                } else {
                    // Fallback to text display
                    statusContent.innerHTML = `<div class="status-text">${JSON.stringify(data, null, 2)}</div>`;
                }
            } catch (error) {
                console.error('Error fetching character status:', error);
                statusContent.innerHTML = `<div class="error-message">Error: ${error.message}</div>`;
            }
        }
        
        // Render structured character status
        function renderStructuredStatus(data) {
            const statusContent = document.getElementById('status-content');
            
            const statusHTML = `
                <div class="status-card">
                    <div class="status-header">
                        <h4>${data.name || 'Adventurer'}</h4>
                        <span class="level">Level ${data.level || 1}</span>
                    </div>
                    
                    <div class="status-attributes">
                        ${data.health !== undefined ? `
                        <div class="attribute">
                            <span class="label">Health:</span>
                            <div class="progress-bar">
                                <div class="progress health" style="width: ${(data.health / (data.max_health || 100) * 100) || 0}%;"></div>
                                <span class="value">${data.health || 0}/${data.max_health || 100}</span>
                            </div>
                        </div>` : ''}
                        
                        ${data.mana !== undefined ? `
                        <div class="attribute">
                            <span class="label">Mana:</span>
                            <div class="progress-bar">
                                <div class="progress mana" style="width: ${(data.mana / (data.max_mana || 100) * 100) || 0}%;"></div>
                                <span class="value">${data.mana || 0}/${data.max_mana || 100}</span>
                            </div>
                        </div>` : ''}
                        
                        ${data.experience !== undefined ? `
                        <div class="attribute">
                            <span class="label">Experience:</span>
                            <div class="progress-bar">
                                <div class="progress exp" style="width: ${(data.experience / (data.experience_to_next || 100) * 100) || 0}%;"></div>
                                <span class="value">${data.experience || 0}/${data.experience_to_next || 100}</span>
                            </div>
                        </div>` : ''}
                    </div>
                    
                    ${(data.attributes || data.strength !== undefined) ? `
                    <div class="status-stats">
                        ${data.attributes ? `
                            ${Object.entries(data.attributes).map(([key, value]) => `
                                <div class="stat">
                                    <span class="label">${key.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')}:</span>
                                    <span class="value">${value}</span>
                                </div>
                            `).join('')}
                        ` : ''}
                        
                        ${data.strength !== undefined ? `
                            <div class="stat">
                                <span class="label">Strength:</span>
                                <span class="value">${data.strength}</span>
                            </div>` : ''}
                            
                        ${data.dexterity !== undefined ? `
                            <div class="stat">
                                <span class="label">Dexterity:</span>
                                <span class="value">${data.dexterity}</span>
                            </div>` : ''}
                            
                        ${data.constitution !== undefined ? `
                            <div class="stat">
                                <span class="label">Constitution:</span>
                                <span class="value">${data.constitution}</span>
                            </div>` : ''}
                            
                        ${data.intelligence !== undefined ? `
                            <div class="stat">
                                <span class="label">Intelligence:</span>
                                <span class="value">${data.intelligence}</span>
                            </div>` : ''}
                            
                        ${data.wisdom !== undefined ? `
                            <div class="stat">
                                <span class="label">Wisdom:</span>
                                <span class="value">${data.wisdom}</span>
                            </div>` : ''}
                            
                        ${data.charisma !== undefined ? `
                            <div class="stat">
                                <span class="label">Charisma:</span>
                                <span class="value">${data.charisma}</span>
                            </div>` : ''}
                            
                        ${data.gold !== undefined ? `
                            <div class="stat gold">
                                <span class="label">Gold:</span>
                                <span class="value">${data.gold}</span>
                            </div>` : ''}
                    </div>` : ''}
                    
                    ${data.equipped ? `
                    <div class="equipment-section">
                        <h5>Equipment</h5>
                        <div class="equipment-grid">
                            ${data.equipped.weapon ? `
                            <div class="equipment-item">
                                <span class="label">Weapon:</span>
                                <span class="value">${data.equipped.weapon.name || 'None'}</span>
                                ${data.equipped.weapon.damage ? `<span class="detail">${data.equipped.weapon.damage} damage</span>` : ''}
                            </div>` : ''}
                            
                            ${data.equipped.armor ? `
                            <div class="equipment-item">
                                <span class="label">Armor:</span>
                                <span class="value">${data.equipped.armor.name || 'None'}</span>
                                ${data.equipped.armor.defense ? `<span class="detail">+${data.equipped.armor.defense} defense</span>` : ''}
                            </div>` : ''}
                            
                            ${data.equipped.accessories && data.equipped.accessories.length > 0 ? `
                            <div class="equipment-item">
                                <span class="label">Accessories:</span>
                                <div class="accessories-list">
                                    ${data.equipped.accessories.map(acc => `
                                        <div class="accessory">
                                            <span class="value">${acc.name || 'Accessory'}</span>
                                            ${acc.bonus ? `<span class="detail">${acc.bonus}</span>` : ''}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>` : ''}
                        </div>
                    </div>` : ''}
                    
                    ${data.location ? `
                    <div class="location-section">
                        <div class="location">
                            <span class="label">Location:</span>
                            <span class="value">${data.location}</span>
                        </div>
                    </div>` : ''}
                </div>
            `;
            
            statusContent.innerHTML = statusHTML;
        }

        function toggleNPCDialogMode() {
            npcDialogMode = !npcDialogMode;
            const npcButton = document.getElementById('npcButton');
            const npcButtonText = document.getElementById('npcButtonText');
            
            if (npcDialogMode) {
                npcButton.classList.add('active');
                npcButtonText.textContent = 'Talking... (Click to stop)';
                addConsoleMessage(CONSOLE_TYPES.INFO, 'NPC dialog mode active. Type your message to talk to NPCs. Say an NPC\'s name to talk to them.');
            } else {
                npcButton.classList.remove('active');
                npcButtonText.textContent = 'Talk to NPC';
                currentNPC = '';
                addConsoleMessage(CONSOLE_TYPES.INFO, 'Exited NPC dialog mode.');
            }
        }

        // Modify the sendConsoleCommand function to handle NPC dialog mode and streaming responses
        async function sendConsoleCommand() {
            const input = document.getElementById('console-input');
            const command = input.value.trim();
            
            if (!command) return;

            // Clear input
            input.value = '';
            
            // Add command to console
            addConsoleMessage(CONSOLE_TYPES.COMMAND, `> ${command}`);

            // Handle NPC dialog mode - everything is treated as dialog to the current NPC
            if (npcDialogMode) {
                let npcName = '';
                let message = command.trim();
                
                // Check if the message starts with an NPC name followed by a comma
                const commaIndex = message.indexOf(',');
                const spaceIndex = message.indexOf(' ');
                
                // If there's a comma before the first space or no space, use that as the NPC name
                if ((commaIndex > 0 && (spaceIndex === -1 || commaIndex < spaceIndex)) || 
                    (spaceIndex === -1 && commaIndex === -1)) {
                    // If there's a comma, split on it
                    if (commaIndex > 0) {
                        npcName = message.substring(0, commaIndex).trim();
                        message = message.substring(commaIndex + 1).trim();
                    } 
                    // If no comma but we have a space, treat first word as NPC name
                    else if (spaceIndex > 0) {
                        npcName = message.substring(0, spaceIndex).trim();
                        message = message.substring(spaceIndex + 1).trim();
                    }
                    // If no delimiter at all, treat entire input as NPC name
                    else {
                        npcName = message;
                        message = '';
                    }
                    
                    // Update current NPC if we got a new name
                    if (npcName && npcName.toLowerCase() !== (currentNPC || '').toLowerCase()) {
                        currentNPC = npcName;
                        addConsoleMessage(CONSOLE_TYPES.INFO, `Now talking to ${currentNPC}`);
                        // If there's no message after the name, just update the NPC
                        if (!message) return;
                    }
                }
                
                // If we don't have an NPC name by now, use the current one or show error
                if (!currentNPC) {
                    addConsoleMessage(CONSOLE_TYPES.ERROR, 'Please specify an NPC name first (e.g., "eldrin, hello" or "guard help")');
                    return;
                }
                
                try {
                    const response = await fetch('/api/get_npc_dialogue', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            npc_name: currentNPC,
                            message: message
                        })
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to talk to NPC');
                    }
                    
                    const data = await response.json();
                    addConsoleMessage(CONSOLE_TYPES.RESPONSE, 
                        `${data.npc_name} (${data.npc_role}): ${data.dialogue}`);
                    
                } catch (error) {
                    let errorMessage = error.message;
                    try {
                        // Try to parse the error response if it's JSON
                        const errorData = JSON.parse(error.message);
                        if (errorData.error_code === 'use_npc_button' || 
                            errorData.error.includes('relationship_status')) {
                            errorMessage = "Please use the 'Talk to NPC' button at the top to interact with NPCs";
                        } else {
                            errorMessage = errorData.error || error.message;
                        }
                    } catch (e) {
                        // If it's not JSON or parsing fails, use the original error message
                        if (errorMessage.includes('relationship_status')) {
                            errorMessage = "Please use the 'Talk to NPC' button at the top to interact with NPCs";
                        }
                    }
                    addConsoleMessage(CONSOLE_TYPES.ERROR, errorMessage);
                }
                return;
            }
            
            // Handle regular commands with SSE stream
            try {
                const response = await fetch('/api/console_command', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        command: command
                    })
                });

                if (!response.ok) {
                    try {
                        const errorData = await response.json();
                        if (errorData.error && errorData.error.includes('relationship_status')) {
                            throw new Error("Please use the 'Talk to NPC' button at the top to interact with NPCs");
                        }
                        throw new Error(errorData.error || 'Failed to process command');
                    } catch (e) {
                        const errorText = await response.text();
                        if (errorText.includes('relationship_status')) {
                            throw new Error("Please use the 'Talk to NPC' button at the top to interact with NPCs");
                        }
                        throw new Error(errorText || 'Failed to process command');
                    }
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder('utf-8');
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    // Decode the chunk of data and add it to the buffer
                    buffer += decoder.decode(value, { stream: true });

                    // Split the buffer into lines (SSE messages are double-newline delimited)
                    const lines = buffer.split('\n\n');
                    buffer = lines.pop(); // Keep incomplete chunk for next iteration

                    // Process each complete message
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const jsonStr = line.replace(/^data: /, '');
                                const message = JSON.parse(jsonStr);

                                // Handle different message types
                                switch(message.type) {
                                    case 'response':
                                    case 'combat_description':
                                    case 'combat_result':
                                        addConsoleMessage(CONSOLE_TYPES.RESPONSE, message.content);
                                        break;
                                    case 'game_state':
                                        // Update UI with new game state if needed
                                        if (message.content && message.content.player) {
                                            updatePlayerStatus(message.content.player);
                                        }
                                        break;
                                    case 'error':
                                        addConsoleMessage(CONSOLE_TYPES.ERROR, message.content);
                                        break;
                                    default:
                                        // For any other type, just show the content
                                        addConsoleMessage(CONSOLE_TYPES.RESPONSE, message.content || 'Command executed');
                                }
                            } catch (err) {
                                console.error('Failed to parse SSE message:', err, line);
                                addConsoleMessage(CONSOLE_TYPES.ERROR, 'Error processing server response');
                            }
                        }
                    }
                }
                
                // Process any remaining data in the buffer
                if (buffer.trim()) {
                    try {
                        const message = JSON.parse(buffer);
                        // Only add the message if it's not the end marker
                        if (message.type !== 'end') {
                            addConsoleMessage(CONSOLE_TYPES.RESPONSE, message.content || 'Command executed');
                        }
                    } catch (e) {
                        console.error('Failed to parse final buffer:', e);
                    }
                }
                
            } catch (error) {
                console.error('Error sending command:', error);
                addConsoleMessage(CONSOLE_TYPES.ERROR, error.message || 'Failed to send command');
            }
        }

        async function lookAround() {
            const consoleContainer = document.getElementById("console-output");

            try {
                const response = await fetch("/api/look_around", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    }
                });

                const data = await response.json();
                if (response.ok) {
                    const description = data.description;

                    // Find existing .console-response or create one if it doesn't exist
                    let responseDiv = consoleContainer.querySelector(".console-response");
                    if (!responseDiv) {
                        responseDiv = document.createElement("div");
                        responseDiv.classList.add("console-response");
                        consoleContainer.appendChild(responseDiv);
                    }

                    // Append new description text
                    responseDiv.textContent += `\n${description}`;

                } else {
                    console.error(data.error);
                }
            } catch (error) {
                console.error("Error:", error);
            }
        }

        async function playerAttack() {
            try {
                const response = await fetch('/api/player_attack', {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed player attack');
                }
                
                addConsoleMessage(CONSOLE_TYPES.RESPONSE, data.description);
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed player attack');
                }
                
                updateEnemyStatus();
                if (data.enemy_dead) {
                    document.getElementById('player-attack').disabled = true;
                    alert('You defeated the enemy!');
                }
            } catch (error) {
                console.error('Error during player attack:', error);
            }
        }
    </script>
</body>
</html>